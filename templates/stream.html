<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Stream</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="../static/css/stream.css">
</head>

<body>
    <div class="header">
        <h5>CAMERA {{ cam_id }}</h5>
    </div>

    <div class="container">
        <div class="help-section">
            <button id="helpBtn" class="help-button">Help?</button>
        </div>

        <div class="main-content">
            <div class="controls">
                <button id="start" title="Start Drawing"><i class="fa-solid fa-pencil"></i></button>
                <button id="edit" title="Edit Zones"><i class="fa-solid fa-pen-to-square"></i></button>
                <button id="delete" class="delete-btn" title="Delete Last Zone"><i
                        class="fa-solid fa-trash-can"></i></button>
                <button id="clear" class="clear-btn" title="Clear All Zones"><i class="fa-solid fa-broom"></i></button>
                <button onclick="window.location.href='/'" title="Back to Home"><i
                        class="fa-solid fa-house"></i></button>
            </div>

            <div class="video-container">
                <div id="loadingOverlay" class="loading-overlay">
                    <div class="spinner"></div>
                    <div>Loading Stream...</div>
                </div>
                <img id="video" src="/video_feed/{{ cam_id }}" alt="Camera Stream" style="display: none;">
                <canvas id="canvas"></canvas>
            </div>

            <div class="stats-panel">
                <div id="stats-content" class="stats-grid">Loading...</div>
            </div>
        </div>
    </div>

    <div id="instructionsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeInstructionsModalBtn">&times;</span>
            <h2>How to Use</h2>
            <div class="instructions-content">
                <section>
                    <h3>How to create zones:</h3>
                    <ul>
                        <li>Click "Start Drawing" to begin creating a zone</li>
                        <li>Click points on the video to create polygon vertices</li>
                        <li>Press Enter to complete the zone</li>
                        <li>Use Delete/Clear buttons to remove zones</li>
                    </ul>
                </section>
                <section>
                    <h3>How to edit zones:</h3>
                    <ul>
                        <li>Click "Edit Zones" to enter edit mode</li>
                        <li>Click and drag any vertex (small red circle) to reshape a zone</li>
                        <li>Click on a zone's label to rename it</li>
                        <li>Click "Stop Editing" to exit edit mode</li>
                    </ul>
                </section>
            </div>
        </div>
    </div>

    <div id="renameModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Rename Zone</h2>
            <input type="text" id="newZoneNameInput" placeholder="Enter new zone name">
            <button id="saveRenameBtn">Save</button>
        </div>
    </div>

    <script>
        const camId = '{{ cam_id }}';
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('start');
        const editBtn = document.getElementById('edit');
        const renameModal = document.getElementById('renameModal');
        const closeRenameModalBtn = document.querySelector('#renameModal .close-button');
        const newZoneNameInput = document.getElementById('newZoneNameInput');
        const saveRenameBtn = document.getElementById('saveRenameBtn');
        const helpBtn = document.getElementById('helpBtn');
        const instructionsModal = document.getElementById('instructionsModal');
        const closeInstructionsModalBtn = document.getElementById('closeInstructionsModalBtn');
        const loadingOverlay = document.getElementById('loadingOverlay');

        let drawing = false;
        let editing = false;
        let currentPoints = [];
        let zones = [];

        let isDraggingPoint = false;
        let draggedZoneIndex = null;
        let draggedPointIndex = null;
        let selectedZoneForRenameIndex = null;
        let statsIntervalId = null;

        /**
         * Generates a unique identifier (UUID) using a standard format.
         * This function creates a version 4 UUID, which is based on random numbers.
         */
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        /**
         * Resizes the canvas element to match the dimensions of the video stream.
         * After resizing, it triggers a redraw of all elements on the canvas.
         */
        function resizeCanvas() {
            const videoRect = video.getBoundingClientRect();
            canvas.width = videoRect.width;
            canvas.height = videoRect.height;
            redraw();
        }

        /**
         * Initializes the video stream and associated data. This involves displaying a loading overlay,
         * setting the video source with a cache-buster, and defining onload and onerror handlers.
         * Upon successful video load, it hides the loading overlay, shows the video, resizes the canvas,
         * loads existing zones, and starts fetching real-time statistics. In case of an error, it displays
         * an error message and attempts to re-initialize the stream after a delay.
         */
        function initializeStream() {
            console.log('Initializing stream...');
            loadingOverlay.style.display = 'flex';
            video.style.display = 'none';

            video.src = `/video_feed/${camId}?_=${new Date().getTime()}`;

            video.onload = null;
            video.onerror = null;

            video.onload = () => {
                console.log('Video stream image loaded.');
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                    video.style.display = 'block';
                    resizeCanvas();
                    loadZones();
                    updateStats();

                    if (statsIntervalId) {
                        clearInterval(statsIntervalId);
                    }
                    statsIntervalId = setInterval(updateStats, 1000);
                }, 1500);
            };

            video.onerror = () => {
                console.error('Error loading video stream image. Retrying in 3 seconds...');
                document.getElementById('stats-content').innerHTML = '<div class="stat-card">Error loading video stream. Retrying...</div>';
                loadingOverlay.innerHTML = '<div style="color:red;">Error loading stream. Retrying...</div><div class="spinner"></div>';
                setTimeout(() => {
                    initializeStream();
                }, 3000);
            };
        }

        window.addEventListener('load', initializeStream);
        window.addEventListener('resize', resizeCanvas);

        /**
         * Handles the `pageshow` event, which fires when a session history entry is being activated.
         * If the page is restored from the back/forward cache, it clears any existing statistics intervals
         * and re-initializes the video stream to ensure fresh data and a responsive UI.
         */
        window.addEventListener('pageshow', function (event) {
            if (event.persisted) {
                console.log('Page restored from Back/Forward Cache. Re-initializing stream.');
                if (statsIntervalId) {
                    clearInterval(statsIntervalId);
                    statsIntervalId = null;
                }
                initializeStream();
            }
        });

        /**
         * Handles the `pagehide` event, which fires when a user navigates away from the page.
         * This function is crucial for resource cleanup, specifically clearing the interval
         * that continuously updates statistics to prevent memory leaks and unnecessary background processes.
         */
        window.addEventListener('pagehide', function (event) {
            if (statsIntervalId) {
                clearInterval(statsIntervalId);
                statsIntervalId = null;
                console.log('Stats interval cleared on pagehide.');
            }
        });

        /**
         * Toggles the drawing mode. When drawing is enabled, it disables the start button,
         * sets the canvas cursor to 'crosshair', and clears any existing points. If editing
         * mode is active, it first disables editing mode before enabling drawing.
         */
        startBtn.onclick = () => {
            if (editing) {
                editing = false;
                editBtn.innerHTML = '<i class="fa-solid fa-pen-to-square"></i>';
                editBtn.title = 'Edit Zones';
                canvas.style.cursor = 'default';
                redraw();
            }
            if (!drawing) {
                drawing = true;
                currentPoints = [];
                startBtn.disabled = true;
                startBtn.title = 'Drawing... (Press Enter to finish)';
                canvas.style.cursor = 'crosshair';
            }
        };

        /**
         * Toggles the editing mode for zones. When activated, it disables drawing,
         * changes the edit button icon and title, and sets the canvas cursor to 'grab'.
         * When deactivated, it reverts these changes and redraws the canvas.
         */
        editBtn.onclick = () => {
            drawing = false;
            startBtn.disabled = false;
            startBtn.title = 'Start Drawing';
            currentPoints = [];

            editing = !editing;
            if (editing) {
                editBtn.innerHTML = '<i class="fa-solid fa-ban"></i>';
                editBtn.title = 'Stop Editing';
                canvas.style.cursor = 'grab';
            } else {
                editBtn.innerHTML = '<i class="fa-solid fa-pen-to-square"></i>';
                editBtn.title = 'Edit Zones';
                canvas.style.cursor = 'default';
            }
            redraw();
        };

        /**
         * Handles the `mousedown` event on the canvas. If in editing mode, it checks if a user
         * clicked near a zone vertex and enables dragging if a vertex is found.
         * If in drawing mode, it adds the current mouse position as a new point to the current zone.
         */
        canvas.onmousedown = e => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const scaleX = video.naturalWidth / video.clientWidth;
            const scaleY = video.naturalHeight / video.clientHeight;
            const scaledMouseX = mouseX * scaleX;
            const scaledMouseY = mouseY * scaleY;

            if (editing) {
                for (let i = 0; i < zones.length; i++) {
                    const zone = zones[i];
                    for (let j = 0; j < zone.points.length; j++) {
                        const [pointX, pointY] = zone.points[j];
                        const dist = Math.sqrt(
                            Math.pow(scaledMouseX - pointX, 2) +
                            Math.pow(scaledMouseY - pointY, 2)
                        );
                        if (dist < 10 * scaleX) {
                            isDraggingPoint = true;
                            draggedZoneIndex = i;
                            draggedPointIndex = j;
                            canvas.style.cursor = 'grabbing';
                            return;
                        }
                    }
                }
            } else if (drawing) {
                currentPoints.push([scaledMouseX, scaledMouseY]);
                redraw();
            }
        };

        /**
         * Handles the `mousemove` event on the canvas. If a point is being dragged in editing mode,
         * it updates the position of the dragged point within the current zone and redraws the canvas.
         * If in editing mode and not dragging, it adjusts the cursor to 'grab' if hovering over a zone vertex.
         */
        canvas.onmousemove = e => {
            if (isDraggingPoint) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const scaleX = video.naturalWidth / video.clientWidth;
                const scaleY = video.naturalHeight / video.clientHeight;

                zones[draggedZoneIndex].points[draggedPointIndex] = [mouseX * scaleX, mouseY * scaleY];
                redraw();
            } else if (editing) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const scaleX = video.naturalWidth / video.clientWidth;
                const scaleY = video.naturalHeight / video.clientHeight;
                let hoverPoint = false;
                for (let i = 0; i < zones.length; i++) {
                    const zone = zones[i];
                    for (let j = 0; j < zone.points.length; j++) {
                        const [pointX, pointY] = zone.points[j];
                        const dist = Math.sqrt(
                            Math.pow(mouseX - pointX / scaleX, 2) +
                            Math.pow(mouseY - pointY / scaleY, 2)
                        );
                        if (dist < 10) {
                            hoverPoint = true;
                            break;
                        }
                    }
                    if (hoverPoint) break;
                }
                canvas.style.cursor = hoverPoint ? 'grab' : 'default';
            }
        };

        /**
         * Handles the `mouseup` event on the canvas. If a point was being dragged,
         * it resets the dragging state and saves the updated zone configurations to the server.
         */
        canvas.onmouseup = () => {
            if (isDraggingPoint) {
                isDraggingPoint = false;
                draggedZoneIndex = null;
                draggedPointIndex = null;
                canvas.style.cursor = 'default';
                saveZones();
            }
        };

        /**
         * Handles the `dblclick` event on the canvas. If in editing mode,
         * it checks if the double-click occurred within a zone's label area.
         * If a label is detected, it opens a modal to allow renaming the zone,
         * pre-populating the input field with the current zone name.
         */
        canvas.ondblclick = e => {
            if (!editing) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const scaleX = video.naturalWidth / video.clientWidth;
            const scaleY = video.naturalHeight / video.clientHeight;
            const scaledMouseX = mouseX * scaleX;
            const scaledMouseY = mouseY * scaleY;

            for (let i = 0; i < zones.length; i++) {
                const zone = zones[i];
                if (zone.points.length > 0) {
                    let sumX = 0;
                    let sumY = 0;
                    for (const [x, y] of zone.points) {
                        sumX += x;
                        sumY += y;
                    }
                    const centroidX = sumX / zone.points.length;
                    const centroidY = sumY / zone.points.length;

                    const displayLabelX = centroidX / scaleX;
                    const displayLabelY = centroidY / scaleY;

                    const textWidth = ctx.measureText(zone.name).width;
                    const textHeight = 14;

                    if (mouseX > displayLabelX && mouseX < displayLabelX + textWidth &&
                        mouseY > displayLabelY - textHeight && mouseY < displayLabelY + 5) {
                        selectedZoneForRenameIndex = i;
                        newZoneNameInput.value = zone.name;
                        renameModal.style.display = 'flex';
                        return;
                    }
                }
            }
        };

        /**
         * Handles keyboard `keydown` events. When the 'Enter' key is pressed
         * while drawing and at least three points have been defined, it completes
         * the current zone, adds it to the list of zones, resets the drawing state,
         * and saves the updated zones to the server.
         */
        document.addEventListener('keydown', e => {
            if (e.key === 'Enter' && drawing && currentPoints.length > 2) {
                zones.push({
                    id: generateUUID(),
                    name: `Zone ${zones.length + 1}`,
                    points: [...currentPoints]
                });
                currentPoints = [];
                drawing = false;
                startBtn.disabled = false;
                startBtn.title = 'Start Drawing';
                canvas.style.cursor = 'default';
                redraw();
                saveZones();
            }
        });

        /**
         * Handles the click event for the delete button. When clicked, it removes
         * the last drawn zone from the `zones` array, redraws the canvas, and
         * saves the updated zone configuration to the server.
         */
        document.getElementById('delete').onclick = () => {
            if (zones.length > 0) {
                zones.pop();
                redraw();
                saveZones();
            }
        };

        /**
         * Handles the click event for the clear button. When clicked, it clears
         * all existing zones, resets the drawing and editing states, restores
         * button texts and titles, sets the canvas cursor to default, redraws the canvas,
         * and saves the empty zone configuration to the server.
         */
        document.getElementById('clear').onclick = () => {
            zones = [];
            currentPoints = [];
            drawing = false;
            editing = false;
            startBtn.disabled = false;
            startBtn.title = 'Start Drawing';
            editBtn.innerHTML = '<i class="fa-solid fa-pen-to-square"></i>';
            editBtn.title = 'Edit Zones';
            canvas.style.cursor = 'default';
            redraw();
            saveZones();
        };

        /**
         * Redraws all zones and currently drawn points on the canvas.
         * It clears the canvas, then iterates through each defined zone,
         * drawing its outline, filling it with a transparent color, and
         * displaying its name. In editing mode, it also draws red circles
         * at each vertex to indicate editability. If the user is currently
         * drawing a new zone, it draws the partial polygon and its vertices.
         */
        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const scaleX = canvas.width / video.naturalWidth;
            const scaleY = canvas.height / video.naturalHeight;

            zones.forEach((zone, index) => {
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';

                ctx.beginPath();
                ctx.moveTo(zone.points[0][0] * scaleX, zone.points[0][1] * scaleY);
                for (let i = 1; i < zone.points.length; i++) {
                    ctx.lineTo(zone.points[i][0] * scaleX, zone.points[i][1] * scaleY);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                if (zone.points.length > 0) {
                    let sumX = 0;
                    let sumY = 0;
                    for (const [x, y] of zone.points) {
                        sumX += x;
                        sumY += y;
                    }
                    const centroidX = sumX / zone.points.length;
                    const centroidY = sumY / zone.points.length;

                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '14px Arial';
                    ctx.fillText(zone.name, centroidX * scaleX + 5, centroidY * scaleY - 5);
                }

                if (editing) {
                    zone.points.forEach(([x, y]) => {
                        ctx.fillStyle = '#cc0000';
                        ctx.beginPath();
                        ctx.arc(x * scaleX, y * scaleY, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = '#800000';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    });
                }
            });

            if (currentPoints.length > 0) {
                ctx.strokeStyle = '#cc0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(currentPoints[0][0] * scaleX, currentPoints[0][1] * scaleY);
                currentPoints.forEach(([x, y]) => ctx.lineTo(x * scaleX, y * scaleY));
                ctx.stroke();

                currentPoints.forEach(([x, y]) => {
                    ctx.fillStyle = '#cc0000';
                    ctx.beginPath();
                    ctx.arc(x * scaleX, y * scaleY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }
        }

        /**
         * Saves the current configuration of zones to the server.
         * It sends a POST request with the zones data as a JSON payload.
         * Errors during the fetch operation are logged to the console.
         */
        function saveZones() {
            fetch(`/save_zones/${camId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ zones: zones })
            }).catch(err => console.error('Error saving zones:', err));
        }

        /**
         * Loads existing zone configurations from the server.
         * It sends a GET request to retrieve the zones data, then updates the
         * local `zones` array and ensures each zone has a unique ID and a default name
         * if not already defined. Finally, it redraws the canvas to display the loaded zones.
         * Errors during the fetch operation are logged to the console.
         */
        function loadZones() {
            fetch(`/save_zones/${camId}`)
                .then(r => r.json())
                .then(data => {
                    if (data && data.zones) {
                        zones = data.zones;
                        zones.forEach((zone, index) => {
                            if (!zone.id) zone.id = generateUUID();
                            if (!zone.name) zone.name = `Zone ${index + 1}`;
                        });
                        redraw();
                    }
                })
                .catch(err => console.error('Error loading zones:', err));
        }

        /**
         * Fetches and updates real-time statistics from the server.
         * It sends a GET request to the statistics endpoint and dynamically
         * populates the 'stats-content' div with the received data, including
         * overall vehicle counts and zone-specific vehicle type counts.
         * If no statistics are available or an error occurs, appropriate messages are displayed.
         */
        function updateStats() {
            fetch(`/stats/${camId}`)
                .then(r => r.json())
                .then(data => {
                    const statsContent = document.getElementById('stats-content');
                    let statsHtml = '';

                    if (Object.keys(data).length === 0) {
                        statsHtml = '<div class="stat-card">No statistics available yet.</div>';
                    } else {
                        statsHtml += `
                                <div class="stat-card">
                                    <strong>Total Vehicles </strong> ${data.total_vehicles || 0}
                                </div>
                            `;

                        if (data.vehicle_type_counts && Object.keys(data.vehicle_type_counts).length > 0) {
                            let typeCountsHtml = '<ul>';
                            for (const [type, count] of Object.entries(data.vehicle_type_counts)) {
                                typeCountsHtml += `<li>${type}: ${count}</li>`;
                            }
                            typeCountsHtml += '</ul>';
                            statsHtml += `
                                <div class="stat-card">
                                    <strong>Overall Vehicle Type Counts:</strong>
                                    ${typeCountsHtml}
                                </div>
                            `;
                        } else {
                            statsHtml += `
                                <div class="stat-card">
                                    No overall vehicle types detected yet.
                                </div>
                            `;
                        }

                        if (data.zone_vehicle_counts && data.zone_vehicle_counts.length > 0) {
                            data.zone_vehicle_counts.forEach((zoneStats, index) => {
                                const zoneName = zones[index] ? zones[index].name : `Zone ${index + 1}`;
                                const zoneTotalObjects = Object.values(zoneStats).reduce((sum, count) => sum + count, 0);
                                let zoneStatsDetailHtml = '<ul>';
                                if (Object.keys(zoneStats).length > 0) {
                                    const sortedVehicleTypes = Object.keys(zoneStats).sort();
                                    sortedVehicleTypes.forEach(type => {
                                        const count = zoneStats[type];
                                        zoneStatsDetailHtml += `<li>${type}: ${count}</li>`;
                                    });
                                } else {
                                    zoneStatsDetailHtml += `<li>No objects detected in this zone.</li>`;
                                }
                                zoneStatsDetailHtml += '</ul>';

                                statsHtml += `
                                <div class="stat-card">
                                    <strong>${zoneName} (Total: ${zoneTotalObjects}):</strong>
                                    ${zoneStatsDetailHtml}
                                </div>
                                `;
                            });
                        } else {
                            statsHtml += `
                                <div class="stat-card">
                                    No zone-specific statistics available yet.
                                </div>
                            `;
                        }
                    }
                    statsContent.innerHTML = statsHtml;
                })
                .catch(err => {
                    console.error('Error fetching stats:', err);
                    document.getElementById('stats-content').innerHTML = '<div class="stat-card">Error loading stats</div>';
                });
        }

        /**
         * Closes the zone renaming modal when the close button is clicked.
         */
        closeRenameModalBtn.onclick = () => {
            renameModal.style.display = 'none';
        };

        /**
         * Saves the new name for a selected zone. It updates the zone's name in the
         * `zones` array, saves the updated zones to the server, redraws the canvas
         * to reflect the name change, updates the statistics display, and then closes
         * the rename modal. The action proceeds only if a zone is selected and a
         * non-empty name is provided.
         */
        saveRenameBtn.onclick = () => {
            if (selectedZoneForRenameIndex !== null && newZoneNameInput.value.trim() !== '') {
                zones[selectedZoneForRenameIndex].name = newZoneNameInput.value.trim();
                saveZones();
                redraw();
                updateStats();
                renameModal.style.display = 'none';
            }
        };

        /**
         * Displays the instructions modal when the help button is clicked.
         */
        helpBtn.onclick = () => {
            instructionsModal.style.display = 'flex';
        };

        /**
         * Closes the instructions modal when its close button is clicked.
         */
        closeInstructionsModalBtn.onclick = () => {
            instructionsModal.style.display = 'none';
        };

        /**
         * Handles click events on the window. If the click target is the rename modal
         * or the instructions modal backdrop, it closes the respective modal.
         */
        window.onclick = (event) => {
            if (event.target == renameModal) {
                renameModal.style.display = 'none';
            }
            if (event.target == instructionsModal) {
                instructionsModal.style.display = 'none';
            }
        };
    </script>
</body>

</html>